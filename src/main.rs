#![deny(warnings)]

use clap::{App, Arg};
use rand::distributions::Alphanumeric;
use rand::Rng;
use std::io::{Read, Write};
use std::net::{Shutdown, TcpStream, ToSocketAddrs};
use std::thread;
use std::time::{Duration, Instant};
use termion::color;

mod average;
use average::Average;

const READ_TIMEOUT: u64 = 200; //[ms]
const WRITE_TIMEOUT: u64 = 200; //[ms]
const LOOP_DELAY: u64 = 0; //[ms]
const CONNECT_TIMEOUT: u64 = 100; //[ms]
const MAX_PACKET_SIZE: usize = 1500; //[bytes]

fn main() {
    let matches = App::new("simple_socket_tester")
        .version("0.1.0")
        .author("Matvei Klimov <klimatt.gu@gmail.com>")
        .about("Simple socket tester")
        .arg(
            Arg::new("ip")
                .short("i".parse().unwrap())
                .about("Ip Address")
                .takes_value(true),
        )
        .arg(
            Arg::new("port")
                .short("p".parse().unwrap())
                .about("Port")
                .takes_value(true),
        )
        .arg(
            Arg::new("max_packet_size") // bytes
                .short("m".parse().unwrap())
                .about("Maximum packet size which can be generated by tester [bytes]")
                .takes_value(true),
        )
        .arg(
            Arg::new("random_packet_size")
                .short("n".parse().unwrap())
                .about("Makes packets with random size in range = 0..max_packet_size")
                .takes_value(false),
        )
        .arg(
            Arg::new("print_all")
                .short("a".parse().unwrap())
                .about("Print all data")
                .takes_value(false),
        )
        .arg(
            Arg::new("loop_delay") // ms
                .short("d".parse().unwrap())
                .about("Sleep timeout between new attempt [ms]")
                .takes_value(true),
        )
        .arg(
            Arg::new("connect_timeout") // ms
                .short("c".parse().unwrap())
                .about("Connecting timeout [ms]")
                .takes_value(true),
        )
        .arg(
            Arg::new("read_timeout") // ms
                .short("r".parse().unwrap())
                .about("Socket read timeout [ms]")
                .takes_value(true),
        )
        .arg(
            Arg::new("write_timeout") // ms
                .short("w".parse().unwrap())
                .about("Socket write timeout [ms]")
                .takes_value(true),
        )
        .get_matches();
    println!("Simple Socket Tester");

    let ip_addr = matches.value_of("ip").unwrap();
    let port = matches.value_of("port").unwrap();
    let random_packet_size = matches.is_present("random_packet_size");
    let print_all = matches.is_present("print_all");
    let max_packet_size = match matches.value_of("max_packet_size") {
        None => MAX_PACKET_SIZE,
        Some(s) => s.parse::<usize>().expect(""),
    };
    let loop_delay = match matches.value_of("loop_delay") {
        None => LOOP_DELAY,
        Some(s) => s.parse::<u64>().expect(""),
    };
    let connect_timeout = match matches.value_of("connect_timeout") {
        None => CONNECT_TIMEOUT,
        Some(s) => s.parse::<u64>().expect(""),
    };
    let read_timeout = match matches.value_of("read_timeout") {
        None => READ_TIMEOUT,
        Some(s) => s.parse::<u64>().expect(""),
    };
    let write_timeout = match matches.value_of("write_timeout") {
        None => WRITE_TIMEOUT,
        Some(s) => s.parse::<u64>().expect(""),
    };
    let t = Instant::now();
    let mut av_bandwidth = Average::<f64>::new(0f64);
    let mut error_cnt: u32 = 0;
    loop {
        println!(
            "{}==============================================================================================",
            color::Fg(color::White),
        );
        match TcpStream::connect_timeout(
            &((ip_addr.to_owned() + ":" + port)
                .to_socket_addrs()
                .unwrap()
                .next()
                .unwrap()),
            Duration::from_millis(connect_timeout),
        ) {
            Ok(mut stream) => {
                println!(
                    "{}{:?} | {}Successfully connected to {} in port {} {}",
                    color::Fg(color::Cyan),
                    t.elapsed(),
                    color::Fg(color::Green),
                    ip_addr,
                    port,
                    color::Fg(color::White)
                );
                stream
                    .set_write_timeout(Some(Duration::from_millis(write_timeout)))
                    .expect("WriteTimeout is invalid");
                stream
                    .set_read_timeout(Some(Duration::from_millis(read_timeout)))
                    .expect("ReadTimeout is invalid");
                stream.set_nodelay(true).expect("set_nodelay call failed");
                loop {
                    let mut rng = rand::thread_rng();
                    let bytes_amount = if random_packet_size {
                        rng.gen_range(0usize..max_packet_size)
                    } else {
                        max_packet_size
                    };
                    let rand_string: String = rng
                        .sample_iter(&Alphanumeric)
                        .take(bytes_amount)
                        .map(char::from)
                        .collect();

                    if print_all {
                        println!(
                            "{}{:?} |{} Sent {} [bytes] : {}{}, {}awaiting reply...",
                            color::Fg(color::Cyan),
                            t.elapsed(),
                            color::Fg(color::Green),
                            rand_string.len(),
                            color::Fg(color::Yellow),
                            rand_string,
                            color::Fg(color::White)
                        );
                    }
                    let send_time = Instant::now();

                    stream.write(rand_string.as_bytes()).unwrap();
                    let mut data = Vec::<u8>::new();
                    data.resize(bytes_amount, 0);
                    match stream.read_exact(&mut data[0..bytes_amount]) {
                        Ok(_) => {
                            if data.as_slice() == rand_string.as_bytes() {
                                let delta_time = Instant::now()
                                    .saturating_duration_since(send_time)
                                    .as_millis();
                                let bandwidth = (8_000 * bytes_amount as u128) as f32
                                    / (1_048_576 * delta_time) as f32;
                                av_bandwidth.add(bandwidth as f64);
                                if print_all {
                                    println!(
                                        "{}{:?} | {}Reply is ok!",
                                        color::Fg(color::Cyan),
                                        t.elapsed(),
                                        color::Fg(color::Green)
                                    );
                                    println!(
                                        "{}{:?} | {}Bandwidth: {}{:.2} [Mbps]",
                                        color::Fg(color::Cyan),
                                        t.elapsed(),
                                        color::Fg(color::White),
                                        color::Fg(color::Magenta),
                                        bandwidth
                                    );
                                }
                            } else {
                                error_cnt += 1;
                                println!(
                                    "{}{:?} | {} Unexpected reply: {}{:?}",
                                    color::Fg(color::Cyan),
                                    t.elapsed(),
                                    color::Fg(color::Red),
                                    color::Fg(color::Yellow),
                                    data
                                );
                                break;
                            }
                        }
                        Err(e) => {
                            error_cnt += 1;
                            println!(
                                "{}{:?} | {}Failed to receive data: {}{}",
                                color::Fg(color::Cyan),
                                t.elapsed(),
                                color::Fg(color::Red),
                                color::Fg(color::Yellow),
                                e
                            );
                            break;
                        }
                    }
                    println!(
                        "{}********************GLOBAL INFO**********************",
                        color::Fg(color::Yellow)
                    );
                    println!(
                        "{}{:?} | {}Average Bandwidth: {}{:.2} [Mbps]",
                        color::Fg(color::Cyan),
                        t.elapsed(),
                        color::Fg(color::White),
                        color::Fg(color::Magenta),
                        av_bandwidth.get()
                    );
                    println!(
                        "{}{:?} | {}Error Counter: {}{}",
                        color::Fg(color::Cyan),
                        t.elapsed(),
                        color::Fg(color::White),
                        color::Fg(color::Red),
                        error_cnt
                    );
                    println!(
                        "{}*****************************************************",
                        color::Fg(color::Yellow)
                    );
                    thread::sleep(Duration::from_millis(loop_delay));
                }
                match stream.shutdown(Shutdown::Both) {
                    Ok(_) => {}
                    Err(e) => {
                        error_cnt += 1;
                        println!(
                            "{}{:?} | {}Stream shutdown error: {}{}",
                            color::Fg(color::Cyan),
                            t.elapsed(),
                            color::Fg(color::Red),
                            color::Fg(color::Yellow),
                            e
                        );
                    }
                }
            }
            Err(e) => {
                error_cnt += 1;
                println!(
                    "{}{:?} | {}Failed to connect: {}{}",
                    color::Fg(color::Cyan),
                    t.elapsed(),
                    color::Fg(color::Red),
                    color::Fg(color::Yellow),
                    e
                );
            }
        }
    }
}
